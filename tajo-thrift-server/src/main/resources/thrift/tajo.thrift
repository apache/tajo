/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ----------------------------------------------------------------
// tajo.thrift
//
// This is a Thrift interface definition file for the Tajo service.
// Target language libraries for C++, Java, Ruby, PHP, (and more) are
// generated by running this file through the Thrift compiler with the
// appropriate flags. The Thrift compiler binary and runtime
// libraries for various languages are available
// from the Apache Incubator (http://thrift.apache.org/)
// ----------------------------------------------------------------

namespace java org.apache.tajo.thrift.generated
namespace cpp  apache.tajo.thrift
namespace rb Apache.Tajo.Thrift
namespace py tajo
namespace perl Tajo
namespace php Tajo

enum TajoThriftDataType {
  NULL_TYPE = 0; // NULL type

  BOOLEAN = 1; // state of true of false [1 byte]

  INT1 = 2; // tinyint [1 byte] [0-255]
  INT2 = 3; // smallint [2 bytes] [-2^15(-32,768) ~ 2^15-1(32,767)]
  INT4 = 4; // int [4 bytes] [-2^31(-2,147,483,648) ~ 2^31-1(2,147,483,647)]
  INT8 = 5; // bigint [8 bytes] [-2^63(-9,223,372,036,854,775,808) ~ 2^63-1(9,223,372,036,854,775,807)]
  UINT1 = 6; // unsigned int1
  UINT2 = 7; // unsigned int2
  UINT4 = 8; // unsigned int4
  UINT8 = 9; // unsigned int8
  FLOAT4 = 10; // variable-precision, inexact [4 bytes]
  FLOAT8 = 11; // variable-precision, inexact [8 bytes]

  NUMERIC = 12; // variable length

  CHAR = 21; // fixed-width n-character string
  NCHAR = 22; // fixed width string supporting an international character set
  VARCHAR = 23; // variable-width string
  NVARCHAR = 24; // variable-width NCHAR string
  TEXT = 25; // variable unlimited length

  DATE = 31;
  TIME = 32;
  TIMEZ = 33;
  TIMESTAMP = 34;
  TIMESTAMPZ = 35;
  INTERVAL = 36;

  BIT = 41; // fixed-width bits. BIT without the length L means a single bit. It can be used for boolean type.
  VARBIT = 42; // variable-width bits
  BINARY = 43; // fixed-width binary strings. BINARY without the length L means a single byte.
  VARBINARY = 44; // variable-width binary strings
  BLOB = 45;

  ANY = 51; // Any type
  UDT = 52; // user-defined function
  PROTOBUF = 53; // protocol buffer type

  INET4 = 91;
  INET6 = 92;

  // array types
  BOOLEAN_ARRAY = 101;
  INT1_ARRAY = 102;
  INT2_ARRAY = 103;
  INT4_ARRAY = 104;
  INT8_ARRAY = 105;
  UINT1_ARRAY = 106;
  UINT2_ARRAY = 107;
  UINT4_ARRAY = 108;
  UINT8_ARRAY = 109;

  FLOAT4_ARRAY = 110;
  FLOAT8_ARRAY = 111;

  NUMERIC_ARRAY = 112;

  CHAR_ARRAY = 121;
  NCHAR_ARRAY = 122;
  VARCHAR_ARRAY = 123;
  NVARCHAR_ARRAY = 124;
  TEXT_ARRAY = 125;

  DATE_ARRAY = 131;
  TIME_ARRAY = 132;
  TIMEZ_ARRAY = 133;
  TIMESTAMP_ARRAY = 134;
  TIMESTAMPZ_ARRAY = 135;
  INTERVAL_ARRAY = 136;
}

exception TServiceException {
  1:string message,
  2:string trace
}

enum TResultCode {
  OK = 0,
  ERROR = 1
}

struct TColumn {
  1:string name,
  2:string simpleName,
  3:TajoThriftDataType dataType;
  4:string dataTypeName,
  5:string sqlDataTypeName,
  6:i32 sqlType
}

struct TSchema {
  1:list<TColumn> columns
}

struct TTableStats {
  1:i64 numRows,
  2:i64 numBytes,
  3:i32 numBlocks,
  4:i32 numShuffleOutputs,
  5:i64 avgRows,
  6:i64 readBytes
}

struct TPartitionMethod {
  1:string tableName,
  2:string partitionType,
  3:string expression,
  4:TSchema expressionSchema
}

struct TTableDesc {
  1:string tableName,
  2:string path;
  3:string storeType,
  4:map<string, string> tableMeta,
  5:TSchema schema,
  6:TTableStats stats,
  7:TPartitionMethod partition,
  8:bool isExternal
}

struct TRowData {
  1: list<bool> nullFlags;
  2: list<binary> columnDatas;
}

struct TQueryResult {
  1:TTableDesc tableDesc,
  2:list<TRowData> rows,
  3:TSchema schema
}

struct TGetQueryStatusResponse {
  1:string resultCode,
  2:string queryId,
  3:string state,
  4:double progress,
  5:i64 submitTime,
  6:i64 finishTime,
  7:bool hasResult,
  8:string errorMessage,
  9:string errorTrace,
  10:string queryMasterHost,
  11:i32 queryMasterPort,
  12:TQueryResult queryResult;
}

struct TServerResponse {
  1:string resultCode,
  2:bool boolResult,
  3:string errorMessage,
  4:string detailErrorMessage,
  5:string sessionId
}

struct TBriefQueryInfo {
  1:string queryId,
  2:string state,
  3:i64 startTime,
  4:i64 finishTime,
  5:string query,
  6:string queryMasterHost,
  7:i32 queryMasterPort,
  8:double progress
}

service TajoThriftService {
  TGetQueryStatusResponse submitQuery(1: string sessionId, 2: string query, 3:bool isJson) throws (1:TServiceException se);
  TQueryResult getQueryResult(1: string sessionId, 2: string queryId, 3: i32 fetchSize) throws (1:TServiceException se);
  TGetQueryStatusResponse getQueryStatus(1: string sessionId, 2: string queryId) throws (1:TServiceException se);
  TServerResponse closeQuery(1: string sessionId, 2: string queryId) throws (1:TServiceException se);
  TServerResponse updateQuery(1: string sessionId, 2: string query) throws (1:TServiceException se);
  TServerResponse createSession(1: string userId, 2: string defaultDatabase) throws (1:TServiceException se);
  TServerResponse closeSession(1: string sessionId) throws (1:TServiceException se);
  TServerResponse refreshSession(1: string sessionId) throws (1:TServiceException se);
  TServerResponse selectDatabase(1: string sessionId, 2: string database) throws (1:TServiceException se);
  string getCurrentDatabase(1:string sessionId) throws (1:TServiceException se);

  TServerResponse killQuery(1: string sessionId, 2: string queryId) throws (1:TServiceException se);
  list<TBriefQueryInfo> getQueryList(1: string sessionId) throws (1:TServiceException se);

  bool existTable(1: string sessionId, 2: string tableName) throws (1:TServiceException se);
  list<string> getTableList(1: string sessionId, 2: string databaseName) throws (1:TServiceException se);
  TTableDesc getTableDesc(1: string sessionId, 2: string tableName) throws (1:TServiceException se);
  bool dropTable(1: string sessionId, 2: string tableName, 3: bool purge) throws (1:TServiceException se);

  list<string> getAllDatabases(1: string sessionId) throws (1:TServiceException se);
  bool createDatabase(1: string sessionId, 2: string databaseName) throws (1:TServiceException se);
  bool dropDatabase(1: string sessionId, 2: string databaseName) throws (1:TServiceException se);
  bool existDatabase(1: string sessionId, 2: string databaseName) throws (1:TServiceException se);

  map<string, string> getAllSessionVariables(1: string sessionId) throws (1:TServiceException se);
  bool updateSessionVariable(1: string sessionId, 2: string key, 3: string value) throws (1:TServiceException se);
  bool unsetSessionVariables(1:string sessionId, 2:string key) throws (1:TServiceException se);
}
