/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

option java_package = "org.apache.tajo.plan.serder";
option java_outer_classname = "PlanProto";
option java_generic_services = false;
option java_generate_equals_and_hash = true;

import "PrimitiveProtos.proto";
import "CatalogProtos.proto";
import "DataTypes.proto";

enum NodeType {
  ROOT = 0;
  EXPRS = 1;
  PROJECTION = 2;
  LIMIT = 3;
  WINDOW_AGG = 4;
  SORT = 5;
  HAVING = 6;
  GROUP_BY = 7;
  DISTINCT_GROUP_BY = 8;
  SELECTION = 9;
  JOIN = 10;
  UNION = 11;
  INTERSECT = 12;
  EXCEPT = 13;
  TABLE_SUBQUERY = 14;
  SCAN = 15;
  PARTITIONS_SCAN = 16;
  BST_INDEX_SCAN = 17;
  STORE = 18;
  INSERT = 19;

  CREATE_DATABASE = 20;
  DROP_DATABASE = 21;
  CREATE_TABLE = 22;
  DROP_TABLE = 23;
  ALTER_TABLESPACE = 24;
  ALTER_TABLE = 25;
  TRUNCATE_TABLE = 26;
}

message LogicalNodeTree {
  repeated LogicalNode nodes = 1;
}

message LogicalNode {
  required int32 sid = 1;
  required int32 pid = 2;
  required NodeType type = 3;
  required SchemaProto in_schema = 4;
  required SchemaProto out_schema = 5;

  optional ScanNode scan = 6;
  optional JoinNode join = 7;
  optional FilterNode filter = 8;
  optional GroupbyNode groupby = 9;
  optional SortNode sort = 11;
  optional LimitNode limit = 12;
  optional WindowAggNode window = 13;
  optional ProjectionNode projection = 14;
  optional EvalExprNode exprEval = 15;
  optional SetNode set = 16;
  optional TableSubQueryNode tableSubQuery = 17;
  optional PersistentStoreNode persistentStore = 18;
  optional StoreTableNodeSpec storeTable = 19;
  optional InsertNodeSpec insert = 20;
  optional CreateTableNodeSpec createTable = 21;
  optional RootNode root = 22;

  optional CreateDatabaseNode createDatabase = 23;
  optional DropDatabaseNode dropDatabase = 24;
  optional DropTableNode dropTable = 25;
}

message ScanNode {
  required TableDescProto table = 1;
  optional string alias = 2;
  repeated Target targets = 4;
  optional EvalTree qual = 5;
}

message FilterNode {
  required int32 childId = 1;
  required EvalTree qual = 2;
}

message JoinNode {
  required int32 leftChildId = 1;
  required int32 rightChildId = 2;
  required JoinType joinType = 3;
  optional EvalTree joinQual = 4;
  repeated Target targets = 5;
}

message GroupbyNode {
  required int32 childId = 1;
  repeated ColumnProto groupingKeys = 2;
  repeated EvalTree aggFunctions = 3;
}

message DistinctGroupbyNode {
  required int32 childId = 1;
  repeated GroupbyNode groupbyNodes = 2;
  repeated Target targets = 3;
  repeated ColumnProto groupingKeys = 4;
  repeated int32 resultId = 5;
}

message SortNode {
  required int32 childId = 1;
  repeated SortSpecProto sortSpecs = 2;
}

message LimitNode {
  required int32 childId = 1;
  required int64 fetchFirstNum = 2;
}

message WindowAggNode {
  required int32 childId = 1;
  repeated ColumnProto partitionKeys = 2;
  repeated SortSpecProto sortSpecs = 3;
  repeated EvalTree windowFunctions = 4;
  required bool  distinct = 5; // if distinct aggregation function is included in window function
  repeated Target targets = 6;
}

message SetNode {
  required int32 leftChildId = 1;
  required int32 rightChildId = 2;
}

message TableSubQueryNode {
  required int32 childId = 1;
  required string tableName = 2;
  repeated Target targets = 3;
}

message PartitionTableScanSpec {
  repeated string paths = 1;
}

message PersistentStoreNode {
  required int32 childId = 1;
  required StoreType storageType = 2;
  required KeyValueSetProto tableProperties = 3;
}

message StoreTableNodeSpec { // required PersistentStoreSpec
  repeated string tableName = 2;
  optional PartitionDescProto partitionDesc = 3;
}

message InsertNodeSpec { // required StoreTableSpec
  required bool overwrite = 1;
  required SchemaProto tableSchema = 2;
  required SchemaProto targetSchema = 3;
  required SchemaProto projectedSchema = 4;
  required string path = 5;
}

message ProjectionNode {
  required int32 childId = 1;
  required bool distinct = 2;
  repeated Target targets = 3;
}

message EvalExprNode {
  repeated Target targets = 1;
}

message RootNode {
  required int32 childId = 1;
}

message CreateDatabaseNode {
  required string dbName = 1;
  required bool ifNotExists = 2;
}

message DropDatabaseNode {
  required string dbName = 1;
  required bool ifExists = 2;
}

message CreateTableNodeSpec { // required PersistentStoreSpec
  required SchemaProto schema = 1;
  required string path = 2;
  required bool external = 3;
  required bool ifNotExists = 4;
}

message DropTableNode {
  required string tableName = 1;
  required bool ifExists = 2;
  required bool purge = 3;
}

message Target {
  required EvalTree expr = 1;
  required string alias = 2;
}

enum JoinType {
  CROSS_JOIN = 0;
  INNER_JOIN = 1;
  LEFT_OUTER_JOIN = 2;
  RIGHT_OUTER_JOIN = 3;
  FULL_OUTER_JOIN = 4;
  UNION_JOIN = 5;
  LEFT_ANTI_JOIN = 6;
  RIGHT_ANTI_JOIN = 7;
  LEFT_SEMI_JOIN = 8;
  RIGHT_SEMI_JOIN = 9;
}

enum EvalType {
  NOT = 0;
  AND = 1;
  OR = 2;
  EQUAL = 3;
  IS_NULL = 4;
  NOT_EQUAL = 5;
  LTH = 6;
  LEQ = 7;
  GTH = 8;
  GEQ = 9;
  PLUS = 10;
  MINUS = 11;
  MODULAR = 12;
  MULTIPLY = 13;
  DIVIDE = 14;

  // Binary Bitwise expressions
  BIT_AND = 15;
  BIT_OR = 16;
  BIT_XOR = 17;

  // Function
  WINDOW_FUNCTION = 18;
  AGG_FUNCTION = 19;
  FUNCTION = 20;

  // String operator or pattern matching predicates
  LIKE = 21;
  SIMILAR_TO = 22;
  REGEX = 23;
  CONCATENATE = 24;

  // Other predicates
  BETWEEN = 25;
  CASE = 26;
  IF_THEN = 27;
  IN = 28;

  // Value or Reference
  SIGNED = 29;
  CAST = 30;
  ROW_CONSTANT = 31;
  FIELD = 32;
  CONST = 33;
}

message EvalTree {
  repeated EvalNode nodes = 1;
}

message EvalNode {
  required int32 id = 1;
  required EvalType type = 2;
  required DataType data_type = 3;

  optional UnaryEval unary = 4; // NOT
  optional BinaryEval binary = 5;
  optional ConstEval const = 6;
  optional ColumnProto field = 7; // field eval
  optional FunctionEval function = 8;
  optional RowConstEval rowConst = 9;
  optional BetweenEval between = 10;
  optional CaseWhenEval casewhen = 11;
  optional IfCondEval ifCond = 12;
}

message UnaryEval {
  required int32 child_id = 1;
  optional DataType castingType = 2;
  optional bool negative = 3;
  optional string timezone = 4;
}

message BinaryEval {
  required int32 lhs_id = 1;
  required int32 rhs_id = 2;
  optional bool negative = 3 [default = false];
}

message BetweenEval {
  required int32 predicand = 1;
  required int32 begin = 2;
  required int32 end = 3;
  optional bool negative = 4 [default = false];
  optional bool symmetric = 5 [default = false];
}

message CaseWhenEval {
  repeated int32 ifConds = 1;
  optional int32 else = 2;
}

message IfCondEval {
  required int32 condition = 1;
  required int32 then = 2;
}

message ConstEval {
  required Datum value = 1;
}

message RowConstEval {
  repeated Datum values = 1;
}

message FunctionEval {
  required FunctionDescProto funcion = 1;
  repeated int32 paramIds = 2;
}

message Datum {
  required Type type = 1;
  optional bool boolean = 2;
  optional int32 int4 = 3;    // int4, date
  optional int64 int8 = 4;    // int8, timestamp, and time
  optional float float4 = 5;
  optional double float8 = 6;
  optional string text = 7;
  optional bytes blob = 8;
  optional Interval interval = 12;
}

message Interval {
  optional int32 month = 1 [default = 0];
  optional int64 msec = 2;
}

enum ShuffleType {
  NONE_SHUFFLE = 0;
  HASH_SHUFFLE = 1;
  RANGE_SHUFFLE = 2;
  SCATTERED_HASH_SHUFFLE = 3;
}

enum TransmitType {
  PUSH_TRANSMIT = 0;
  PULL_TRANSMIT = 1;
  FILE_WRITE = 2;
}